# -*- coding: utf-8 -*-
"""popularity.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wG2e5HeGdd-TSz5E2EReH_pA0FBfgFUK
"""

import streamlit as st
import pandas as pd
import json
import numpy as np
from sklearn.preprocessing import StandardScaler
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report
from sklearn.neighbors import KNeighborsClassifier
from sklearn.ensemble import RandomForestClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.svm import SVC
from xgboost import XGBClassifier
from sklearn.decomposition import PCA
import matplotlib.pyplot as plt
import seaborn as sns

st.set_page_config(page_title="ğŸµ Song Recommender", layout="wide")

@st.cache_data
def load_spotify_data():
    df = pd.read_csv("spotify_tracks.csv")
    needed = ['danceability', 'energy', 'loudness', 'speechiness', 'acousticness',
              'instrumentalness', 'liveness', 'tempo', 'duration_ms', 'valence', 'popularity']
    df[needed] = df[needed].fillna(df[needed].mean())
    df = df.drop_duplicates(subset=['track_name', 'track_genre'], keep='first')
    df['liked'] = df['popularity'].apply(lambda x: 1 if x >= 60 else 0)
    return df

@st.cache_data
def get_pca(X_scaled):
    pca = PCA(n_components=2)
    return pca.fit_transform(X_scaled)

@st.cache_data
def compute_similarity(user_scaled, df_scaled):
    return cosine_similarity(user_scaled, df_scaled)[0]

spotify_df = load_spotify_data()
model_features = ['danceability', 'energy', 'loudness', 'speechiness', 'acousticness',
                  'instrumentalness', 'liveness', 'tempo', 'duration_ms']

page = st.sidebar.selectbox("Choose a view", ["Recommendation System", "EDA Dashboard"])

if page == "EDA Dashboard":
    st.title("ğŸ“Š Spotify Dataset - EDA Dashboard")
    st.write(f"**Total Songs:** {spotify_df.shape[0]}")
    st.write("### Summary Statistics")
    st.dataframe(spotify_df[model_features + ['valence', 'popularity']].describe())

    st.write("### Missing Values")
    missing = spotify_df.isnull().sum()
    st.dataframe(missing[missing > 0])

    st.write("### Genre Distribution")
    genre_counts = spotify_df['track_genre'].value_counts().head(20)
    st.bar_chart(genre_counts)

    st.write("### Correlation Heatmap")
    corr = spotify_df[model_features + ['valence', 'popularity']].corr()
    fig, ax = plt.subplots(figsize=(10, 6))
    sns.heatmap(corr, annot=True, cmap='coolwarm', ax=ax)
    st.pyplot(fig)

    st.write("### Feature Distributions")
    selected_feature = st.selectbox("Select a feature to plot", model_features)
    fig2, ax2 = plt.subplots()
    sns.histplot(spotify_df[selected_feature], kde=True, ax=ax2, bins=30)
    ax2.set_title(f"Distribution of {selected_feature}")
    st.pyplot(fig2)

else:
    st.title("ğŸµ Enhanced Spotify Song Recommendation System")
    st.subheader("ğŸ“Š Model Evaluation")

    X = spotify_df[model_features]
    y = spotify_df['liked']

    scaler = StandardScaler()
    X_scaled = scaler.fit_transform(X)
    X_train, X_test, y_train, y_test = train_test_split(X_scaled, y, test_size=0.2, random_state=42)

    reports = {}

    knn = KNeighborsClassifier(n_neighbors=5)
    knn.fit(X_train, y_train)
    reports["KNN"] = classification_report(y_test, knn.predict(X_test), zero_division=0)

    rf = RandomForestClassifier()
    rf.fit(X_train, y_train)
    reports["Random Forest"] = classification_report(y_test, rf.predict(X_test), zero_division=0)

    logreg = LogisticRegression(max_iter=1000, class_weight='balanced')
    logreg.fit(X_train, y_train)
    reports["Logistic Regression"] = classification_report(y_test, logreg.predict(X_test), zero_division=0)

    svm = SVC(class_weight='balanced')
    svm.fit(X_train, y_train)
    reports["SVM"] = classification_report(y_test, svm.predict(X_test), zero_division=0)

    xgb = XGBClassifier(use_label_encoder=False, eval_metric='logloss')
    xgb.fit(X_train, y_train)
    reports["XGBoost"] = classification_report(y_test, xgb.predict(X_test), zero_division=0)

    model_to_view = st.selectbox("ğŸ“ˆ Select a model to view its classification report", list(reports.keys()))
    st.text(reports[model_to_view])

    uploaded_file = st.file_uploader("ğŸ“‚ Upload your liked songs playlist (.json)", type="json")

    if uploaded_file:
        playlist_data = json.load(uploaded_file)
        playlist_df = pd.DataFrame(playlist_data)

        available_features = [f for f in model_features if f in playlist_df.columns]
        if not available_features:
            st.error("ğŸš« Playlist missing required features.")
        else:
            playlist_df = playlist_df.dropna(subset=available_features)
            user_profile_vector = playlist_df[available_features].mean().values.reshape(1, -1)

            scaler_subset = StandardScaler()
            scaler_subset.fit(spotify_df[available_features])
            user_scaled = scaler_subset.transform(user_profile_vector)

            filter_type = st.radio("ğŸ” Apply a filter?", ["None", "By Genre", "By Mood"])
            filtered_df = spotify_df.copy()

            if filter_type == "By Genre":
                genres = spotify_df['track_genre'].dropna().unique().tolist()
                selected_genre = st.selectbox("ğŸ¼ Select Genre", sorted(genres))
                filtered_df = filtered_df[filtered_df['track_genre'].str.contains(selected_genre, case=False, na=False)]

            elif filter_type == "By Mood":
                mood = st.selectbox("ğŸ· Select Mood", ["Energetic + Happy", "Calm + Low Valence"])
                if mood == "Energetic + Happy":
                    filtered_df = filtered_df[(filtered_df['energy'] > 0.7) & (filtered_df['valence'] > 0.7)]
                else:
                    filtered_df = filtered_df[(filtered_df['energy'] < 0.4) & (filtered_df['valence'] < 0.4)]

            # Optional: limit for performance
            filtered_df = filtered_df.head(10000)

            if not filtered_df.empty:
                df_scaled = scaler_subset.transform(filtered_df[available_features])
                similarity = compute_similarity(user_scaled, df_scaled)
                filtered_df = filtered_df.copy()
                filtered_df['similarity'] = similarity

                top_df = filtered_df.sort_values(by='similarity', ascending=False).head(50)
                top_df = top_df.drop_duplicates(subset=['track_name', 'track_genre'])
                top_df = top_df.sample(n=min(10, len(top_df)), random_state=42)

                st.subheader("ğŸŒŸ Diverse Recommendations Just for You")
                st.dataframe(top_df[['track_name', 'track_genre', 'similarity']])
            else:
                st.warning("âš ï¸ No songs match your filter.")

            if st.checkbox("Show PCA Visualization"):
                X_reduced = get_pca(X_scaled)
                pca_df = pd.DataFrame(X_reduced, columns=["PC1", "PC2"])
                pca_df["liked"] = y.values

                fig, ax = plt.subplots()
                scatter = ax.scatter(pca_df["PC1"], pca_df["PC2"], c=pca_df["liked"], cmap="coolwarm", alpha=0.6)
                ax.set_title("PCA of Spotify Songs")
                ax.set_xlabel("PC1")
                ax.set_ylabel("PC2")
                st.pyplot(fig)
    else:
        st.info("ğŸ‘ˆ Upload your liked songs playlist to get recommendations.")