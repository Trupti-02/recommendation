# -*- coding: utf-8 -*-
"""music.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EdSrJjaxQ8BLV0wIgrJ86ajCMRe4CeAr
"""


# --------------------------------------
# 🎵 Spotify AI Recommender - Full App
# --------------------------------------

# 📦 Imports
import streamlit as st
import pandas as pd
import numpy as np
import json
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report, accuracy_score, f1_score, roc_auc_score, roc_curve
from sklearn.ensemble import RandomForestClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.svm import SVC
from xgboost import XGBClassifier
from sklearn.metrics.pairwise import cosine_similarity
import matplotlib.pyplot as plt
import seaborn as sns

# 💠 Streamlit App Config
st.set_page_config(page_title="🎵 Spotify AI Recommender", layout="wide")

# --------------------------------------
# 🗕 Load Data
# --------------------------------------
@st.cache_data(show_spinner=True)
def load_data():
    df = pd.read_csv("spotify_tracks.csv", low_memory=False)
    df = df.drop_duplicates(subset=['track_name', 'track_genre'], keep='first')
    audio_cols = ['danceability', 'energy', 'loudness', 'speechiness', 'acousticness',
                  'instrumentalness', 'liveness', 'tempo', 'duration_ms', 'valence']
    df[audio_cols] = df[audio_cols].fillna(df[audio_cols].mean()).astype(np.float32)
    return df, audio_cols

# 📊 Load and prepare data
spotify_df, model_features = load_data()
X_valence = spotify_df[model_features[:-1]]
y_valence = (spotify_df['valence'] > 0.5).astype(int)
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X_valence)
X_train, X_test, y_train, y_test = train_test_split(X_scaled, y_valence, test_size=0.2, random_state=42)

# --------------------------------------
# 🔍 Sidebar Navigation
# --------------------------------------
st.sidebar.title("Navigation")
page = st.sidebar.radio("Go to", [
    "EDA Dashboard",
    "Model Evaluation",
    "ML-Based Recommendation",
    "🔁 Cosine Similarity Recommendation"
])

# --------------------------------------
# 📊 EDA Dashboard
# --------------------------------------
if page == "EDA Dashboard":
    st.title("📊 Spotify Dataset - EDA Dashboard")
    st.write(f"*Total Records:* {spotify_df.shape[0]:,}")
    st.dataframe(spotify_df[model_features].describe(), use_container_width=True)

    st.subheader("🎷 Genre Distribution (Top 20)")
    st.bar_chart(spotify_df['track_genre'].value_counts().head(20))

    st.subheader("📈 Correlation Heatmap")
    fig, ax = plt.subplots(figsize=(10, 6))
    sns.heatmap(spotify_df[model_features].corr(), annot=False, cmap='coolwarm', ax=ax)
    st.pyplot(fig)

    st.subheader("🔍 Feature Histogram")
    feature = st.selectbox("Choose Feature", model_features)
    fig2, ax2 = plt.subplots()
    sns.histplot(spotify_df[feature], kde=True, ax=ax2, bins=30)
    st.pyplot(fig2)

# --------------------------------------
# 🧠 Model Evaluation
# --------------------------------------
elif page == "Model Evaluation":
    st.title("🧠 Model Evaluation - Predicting Valence")
    models = {
        "Logistic Regression": LogisticRegression(max_iter=1000),
        "Random Forest": RandomForestClassifier(n_estimators=200),
        "SVM": SVC(probability=True),
        "XGBoost": XGBClassifier(use_label_encoder=False, eval_metric='logloss')
    }

    results = []
    fig, ax = plt.subplots(figsize=(8, 6))
    best_auc = 0
    best_model = None
    selected_model_name = ""

    for name, model in models.items():
        model.fit(X_train, y_train)
        y_pred = model.predict(X_test)
        y_prob = model.predict_proba(X_test)[:, 1]

        acc = accuracy_score(y_test, y_pred)
        f1 = f1_score(y_test, y_pred)
        auc = roc_auc_score(y_test, y_prob)
        results.append({"Model": name, "Accuracy": acc, "F1 Score": f1, "ROC AUC": auc})

        st.markdown(f"### 📌 {name} Performance")
        st.text(classification_report(y_test, y_pred))
        st.markdown(f"*Accuracy:* {acc:.4f} | *F1 Score:* {f1:.4f} | *ROC AUC:* {auc:.4f}")

        if auc > best_auc:
            best_auc = auc
            best_model = model
            selected_model_name = name

        fpr, tpr, _ = roc_curve(y_test, y_prob)
        ax.plot(fpr, tpr, label=f"{name} (AUC = {auc:.2f})")

    ax.plot([0, 1], [0, 1], linestyle='--', color='gray')
    ax.set_xlabel("False Positive Rate")
    ax.set_ylabel("True Positive Rate")
    ax.set_title("ROC Curve Comparison")
    ax.legend()
    st.pyplot(fig)

    results_df = pd.DataFrame(results).sort_values("ROC AUC", ascending=False)
    st.subheader("📊 Model Performance Summary")
    st.dataframe(results_df.style.format({"Accuracy": "{:.4f}", "F1 Score": "{:.4f}", "ROC AUC": "{:.4f}"}))

    st.success(f"✅ Best model selected for prediction: {selected_model_name}")
    st.session_state.best_model = best_model
    st.session_state.selected_model_name = selected_model_name

# --------------------------------------
# 🎵 ML-Based Recommendation
# --------------------------------------
elif page == "ML-Based Recommendation":
    st.title("🎵 ML-Based Mood Song Recommender")

    if "best_model" not in st.session_state:
        st.warning("Please evaluate models first from the 'Model Evaluation' tab.")
    else:
        valence_model = st.session_state.best_model
        selected_model_name = st.session_state.selected_model_name
        valence_model.fit(X_scaled, y_valence)
        spotify_df['predicted_valence'] = valence_model.predict(X_scaled)

        st.markdown(f"*Using Model:* {selected_model_name} for valence prediction")

        filter_choice = st.radio("Filter by", ["None", "Genre", "Mood"])
        filtered_df = spotify_df.copy()

        uploaded_file = st.file_uploader("Or upload a playlist JSON file for personalized recommendations", type="json")

        if uploaded_file:
            try:
                user_data = json.load(uploaded_file)
                user_df = pd.DataFrame(user_data)
                user_df = user_df.dropna(subset=model_features[:-1])
                st.session_state.user_df = user_df

                user_scaled = scaler.transform(user_df[model_features[:-1]])
                user_predictions = valence_model.predict(user_scaled)
                user_df['predicted_valence'] = user_predictions

                user_mood = 0 if user_df['predicted_valence'].mean() < 0.5 else 1
                mood_label = "Calm" if user_mood == 0 else "Happy"
                st.success(f"✅ Playlist uploaded — inferred mood: *{mood_label}*")

                if filter_choice == "Genre":
                    genres = sorted(spotify_df['track_genre'].dropna().unique())
                    genre_filter = st.selectbox("Select Genre", genres)
                    filtered_df = spotify_df[
                        (spotify_df['track_genre'].str.lower() == genre_filter.lower()) &
                        (spotify_df['predicted_valence'] == user_mood)
                    ]
                elif filter_choice == "Mood":
                    mood = st.radio("Select Mood", ["Happy", "Calm"])
                    mood_val = 1 if mood == "Happy" else 0
                    filtered_df = spotify_df[spotify_df['predicted_valence'] == mood_val]
                elif filter_choice == "None":
                    filtered_df = spotify_df[spotify_df['predicted_valence'] == user_mood]

            except Exception as e:
                st.error(f"❌ Error processing uploaded file: {e}")

        if not filtered_df.empty:
            top_k = st.slider("Select number of songs to recommend", 5, 50, 10)
            recommendations = filtered_df.sample(top_k)
            st.subheader("🎷 Recommended Songs")
            st.dataframe(recommendations[['track_name', 'track_genre', 'energy', 'valence']], use_container_width=True)

        elif "user_df" in st.session_state:
            user_df = st.session_state.user_df
            st.subheader("🎷 Predictions for Uploaded Songs")
            st.dataframe(user_df[['track_name', 'track_genre', 'energy', 'predicted_valence']], use_container_width=True)
        else:
            st.warning("No songs found for the selected filter.")

# --------------------------------------
# 🔁 Cosine Similarity Recommendation
# --------------------------------------
elif page == "🔁 Cosine Similarity Recommendation":
    st.title("🔁 Content-Based Song Recommender (Cosine Similarity)")

    option = st.radio("Choose a method", ["Select a song", "Upload a playlist"])
    
    audio_features = model_features[:-1]  # exclude valence
    scaled_features = scaler.fit_transform(spotify_df[audio_features])
    cosine_matrix = cosine_similarity(scaled_features)

    if option == "Select a song":
        track_names = spotify_df['track_name'].unique()
        selected_track = st.selectbox("Choose a song", track_names)

        selected_idx = spotify_df[spotify_df['track_name'] == selected_track].index[0]
        similarity_scores = list(enumerate(cosine_matrix[selected_idx]))
        similarity_scores = sorted(similarity_scores, key=lambda x: x[1], reverse=True)[1:51]

        top_n = st.slider("Number of recommendations", 5, 50, 10)
        top_indices = [i[0] for i in similarity_scores[:top_n]]
        recommended = spotify_df.iloc[top_indices][['track_name', 'track_genre', 'energy', 'valence']]

        st.subheader("🎧 Top Similar Songs")
        st.dataframe(recommended, use_container_width=True)

    elif option == "Upload a playlist":
        uploaded_file = st.file_uploader("Upload your playlist (JSON format)", type="json")
        if uploaded_file:
            try:
                user_data = json.load(uploaded_file)
                user_df = pd.DataFrame(user_data)
                user_df = user_df.dropna(subset=audio_features)
                user_scaled = scaler.transform(user_df[audio_features])
                dataset_scaled = scaler.transform(spotify_df[audio_features])
                sim_scores = cosine_similarity(user_scaled, dataset_scaled)

                avg_scores = np.mean(sim_scores, axis=0)
                top_n = st.slider("Number of recommendations", 5, 50, 10)
                top_indices = avg_scores.argsort()[-top_n:][::-1]
                recommended = spotify_df.iloc[top_indices][['track_name', 'track_genre', 'energy', 'valence']]

                st.subheader("🎧 Top Similar Songs (Playlist-Based)")
                st.dataframe(recommended, use_container_width=True)
            except Exception as e:
                st.error(f"Failed to process playlist: {e}")

